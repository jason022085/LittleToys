# -*- coding: utf-8 -*-
"""CNN7

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NPtumIemeYt7J0qCIExawyv3-jLYycWF

# 連線以及讀取套件
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt #專業繪圖套件

#%%
#讀取資料


X = np.load('D:/Anaconda3/mycode/chart7/data200_7.npy')
y = np.load('D:/Anaconda3/mycode/chart7/target200_7.npy')

#%%
# 分割訓練和測試集


from sklearn.model_selection import train_test_split
X_train , X_test ,y_train, y_test = train_test_split(X,y,test_size=0.3,random_state=1,stratify=y)
print("data分割完成")

X_train =X_train.reshape(len(X_train),200,200,1)
X_test =X_test.reshape(len(X_test),200,200,1)
from keras.utils import np_utils#1-hot encoding
y_train = np_utils.to_categorical(y_train,7)
y_test = np_utils.to_categorical(y_test,7)
#%%
"""# 讀取一個CNN模型"""

from keras.models import Sequential
from keras.layers import Activation,Dense,Flatten,Dropout,AlphaDropout #flatten是要將矩陣拉平成向量
from keras.layers import Conv2D,MaxPooling2D,regularizers #CNN與NN不同的地方在這
from keras.layers import ReLU,BatchNormalization
from keras.optimizers import SGD,Adam
import keras as kr

model = kr.models.load_model("D:/Anaconda3/mycode/chart7/model_cnn7_90.h5")#儲存模型
#在測試集上的正確率達到90%
model.summary()

"""# 模型效能與成果"""

predict = model.predict_classes(X_test)
rad = np.random.randint(0,len(X_test))
print("第",rad,"張")
print('0=長條,1=直方,2=圓餅,3=泡泡,4=散點,5=折線圖,6=其他')
print("預測為:",predict[rad])
print("實際為:",y_test[rad])
image = X_test[rad].reshape(200,200)
plt.figure(num = 'haha' ,figsize=(5,5))
plt.imshow(image,cmap='gray')

(err,acc) = model.evaluate(X_test,y_test)
print("(err,acc) = ",(err,acc))

#%%
def plot_confusion_matrix(confusion_matrix, classes,
                          normalize=False,
                          title=None,
                          cmap=plt.cm.Blues):
    """
    This function prints and plots the confusion matrix.
    Normalization can be applied by setting `normalize=True`.
    """
    if not title:
        if normalize:
            title = 'Normalized confusion matrix'
        else:
            title = 'Confusion matrix, without normalization'

    # Compute confusion matrix
    cm = confusion_matrix
    if normalize:
        cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]
        print("Normalized confusion matrix")
    else:
        print('Confusion matrix, without normalization')

    fig, ax = plt.subplots(figsize=(20, 10))
    im = ax.imshow(cm, interpolation='nearest', cmap=cmap)
    ax.figure.colorbar(im, ax=ax)
    # We want to show all ticks...
    ax.set(xticks=np.arange(cm.shape[1]),
           yticks=np.arange(cm.shape[0]),
           # ... and label them with the respective list entries
           xticklabels=classes, yticklabels=classes,
           title=title,
           ylabel='True label',
           xlabel='Predicted label')

    # Rotate the tick labels and set their alignment.
    plt.setp(ax.get_xticklabels(), rotation=45, ha="right",
             rotation_mode="anchor")

    # Loop over data dimensions and create text annotations.
    fmt = '.2f' if normalize else 'd'
    thresh = cm.max() / 2.
    for i in range(cm.shape[0]):
        for j in range(cm.shape[1]):
            ax.text(j, i, format(cm[i, j], fmt),
                    ha="center", va="center",
                    color="white" if cm[i, j] > thresh else "black")
    fig.tight_layout()
    plt.show()

classes = ['bar', 'hist', 'pie', 'bub', 'scat', 'line','fool']

index = np.argwhere(y_test == 1 )
#print(index)
print(index[:,1])
y_test_raw = index[:,1]

from sklearn.metrics import confusion_matrix
from sklearn.metrics import classification_report
y_pred = model.predict_classes(X_test)
cmcnn = confusion_matrix(y_test_raw, y_pred)
plot_confusion_matrix(cmcnn,classes)

print('Accuracy:', model.evaluate(X_test,y_test))
print(classification_report(y_test_raw, y_pred, target_names=classes))

#%%

"""# 隱藏層的可視化"""

#submodel
rad = 4
from keras.models import Model
inter_layer_model = Model(inputs=model.input,outputs=model.get_layer('conv2d_25').output)

inter_output = inter_layer_model.predict(X_test)
print(inter_output.shape)
inter_img = inter_output[rad]

#第一層可視化
for i in range(1,10):
    plt.figure(num = '卷積核作用後' ,figsize=(12,12))
    plt.subplot( 3,3,i)
    plt.imshow(inter_img[:,:,i],cmap='gray')


#%%
#submodel
from keras.models import Model
inter_layer_model = Model(inputs=model.input,outputs=model.get_layer('conv2d_26').output)

inter_output = inter_layer_model.predict(X_test)
print(inter_output.shape)
inter_img = inter_output[rad]

#第一層可視化
for i in range(1,10):
    plt.figure(num = '卷積核作用後' ,figsize=(12,12))
    plt.subplot( 3,3,i)
    plt.imshow(inter_img[:,:,i],cmap='gray')
#%%
#submodel
from keras.models import Model
inter_layer_model = Model(inputs=model.input,outputs=model.get_layer('max_pooling2d_16').output)

inter_output = inter_layer_model.predict(X_test)
print(inter_output.shape)
inter_img = inter_output[rad]

#第一層可視化
for i in range(1,10):
    plt.figure(num = '卷積核作用後' ,figsize=(12,12))
    plt.subplot( 3,3,i)
    plt.imshow(inter_img[:,:,i],cmap='gray')
    #%%
#submodel
from keras.models import Model
inter_layer_model = Model(inputs=model.input,outputs=model.get_layer('conv2d_29').output)

inter_output = inter_layer_model.predict(X_test)
print(inter_output.shape)
inter_img = inter_output[rad]

#第一層可視化
for i in range(1,10):
    plt.figure(num = '卷積核作用後' ,figsize=(12,12))
    plt.subplot( 3,3,i)
    plt.imshow(inter_img[:,:,i],cmap='gray')
    #%%
#submodel
from keras.models import Model
inter_layer_model = Model(inputs=model.input,outputs=model.get_layer('conv2d_30').output)

inter_output = inter_layer_model.predict(X_test)
print(inter_output.shape)
inter_img = inter_output[rad]

#第一層可視化
for i in range(1,10):
    plt.figure(num = '卷積核作用後' ,figsize=(12,12))
    plt.subplot( 3,3,i)
    plt.imshow(inter_img[:,:,i],cmap='gray')
    #%%
#submodel
from keras.models import Model
inter_layer_model = Model(inputs=model.input,outputs=model.get_layer('max_pooling2d_17').output)

inter_output = inter_layer_model.predict(X_test)
print(inter_output.shape)
inter_img = inter_output[rad]

#第一層可視化
for i in range(1,10):
    plt.figure(num = '卷積核作用後' ,figsize=(12,12))
    plt.subplot( 3,3,i)
    plt.imshow(inter_img[:,:,i],cmap='gray')

#%%
#submodel
from keras.models import Model
inter_layer_model = Model(inputs=model.input,outputs=model.get_layer('conv2d_29').output)

inter_output = inter_layer_model.predict(X_test)
print(inter_output.shape)
inter_img = inter_output[rad]

#第一層可視化
for i in range(1,10):
    plt.figure(num = '卷積核作用後' ,figsize=(12,12))
    plt.subplot( 3,3,i)
    plt.imshow(inter_img[:,:,i],cmap='gray')
#%%
#submodel
from keras.models import Model
inter_layer_model = Model(inputs=model.input,outputs=model.get_layer('max_pooling2d_18').output)

inter_output = inter_layer_model.predict(X_test)
print(inter_output.shape)
inter_img = inter_output[rad]

#第一層可視化
for i in range(1,10):
    plt.figure(num = '卷積核作用後' ,figsize=(12,12))
    plt.subplot( 3,3,i)
    plt.imshow(inter_img[:,:,i],cmap='gray')
    #%%
#submodel
from keras.models import Model
inter_layer_model = Model(inputs=model.input,outputs=model.get_layer('conv2d_31').output)

inter_output = inter_layer_model.predict(X_test)
print(inter_output.shape)
inter_img = inter_output[rad]

#第一層可視化
for i in range(1,10):
    plt.figure(num = '卷積核作用後' ,figsize=(12,12))
    plt.subplot( 3,3,i)
    plt.imshow(inter_img[:,:,i],cmap='gray')
    #%%
#submodel
from keras.models import Model
inter_layer_model = Model(inputs=model.input,outputs=model.get_layer('max_pooling2d_19').output)

inter_output = inter_layer_model.predict(X_test)
print(inter_output.shape)
inter_img = inter_output[rad]

#第一層可視化
for i in range(1,10):
    plt.figure(num = '卷積核作用後' ,figsize=(12,12))
    plt.subplot( 3,3,i)
    plt.imshow(inter_img[:,:,i],cmap='gray')
    #%%
#submodel
from keras.models import Model
inter_layer_model = Model(inputs=model.input,outputs=model.get_layer('conv2d_32').output)

inter_output = inter_layer_model.predict(X_test)
print(inter_output.shape)
inter_img = inter_output[rad]

#第一層可視化
for i in range(1,10):
    plt.figure(num = '卷積核作用後' ,figsize=(12,12))
    plt.subplot( 3,3,i)
    plt.imshow(inter_img[:,:,i],cmap='gray')
    #%%
#submodel
from keras.models import Model
inter_layer_model = Model(inputs=model.input,outputs=model.get_layer('max_pooling2d_20').output)

inter_output = inter_layer_model.predict(X_test)
print(inter_output.shape)
inter_img = inter_output[rad]

#都是黑的怎麼辦?
for i in range(1,10):
    plt.figure(num = '卷積核作用後' ,figsize=(12,12))
    plt.subplot( 3,3,i)
    plt.imshow(inter_img[:,:,i],cmap='gray')
#%%10張疊起來看看
img_last = (inter_img[:,:,100]+inter_img[:,:,200]+inter_img[:,:,300]+inter_img[:,:,400]+inter_img[:,:,500]+
inter_img[:,:,600]+inter_img[:,:,700]+inter_img[:,:,800]+inter_img[:,:,900]+inter_img[:,:,1000])/10
plt.imshow(img_last,cmap="gray")